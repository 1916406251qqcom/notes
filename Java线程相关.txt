1、Java中如何停止一个线程

	可以使用stop()方法和suspend()方法来终止线程的执行。当用stop()方法来终止线程时。它会释放已经锁定的所有监视资源。如果当前任何一个受这些监视资源保护的对象处于一个不一致的状态，其它线程将会“看”到这个不一致的状态，这可能会导致程序执行的不确定性，并且这种问题很难被定位。
	
	当用suspend()方法时，容易发生死锁。因为调用suspend()方法不会释放锁。
	
	之后Java API的设计者就没有提供一个兼容且线程安全的方法来停止一个线程。当run() 或者 call() 方法执行完的时候线程会自动结束。如果要手动结束一个线程，可以用volatile 布尔变量来退出run()方法的循环或者是取消任务来中断线程。或者使用interrupt()方法来打破阻塞的情况，即当interrupt()方法被调用时，会抛出interruptedException异常，可以通过在run()方法中捕获这个异常来让线程安全退出。

2、一个线程运行时发生异常会怎样
	
	如果异常没有被捕获该线程将会停止执行。
	
3、如何在两个线程间共享数据

	可以通过共享对象来实现这个目的，或者是使用像阻塞队列这样并发的数据结构。
	
4、Java中notify 和 notifyAll有什么区别

	notify()方法不能唤醒某个具体的线程，所以只有一个线程在等待的时候它才有用武之地（即它唤醒等待队列的
	第一个线程）。而notifyAll()唤醒等待某对象的所有线程，并允许他们争夺锁，确保了至少有一个线程能继续
	运行。
	
5、为什么wait, notify 和 notifyAll这些方法不在thread类里面
	JAVA提供的锁是对象级的而不是线程级的，每个对象都有锁，通过线程获得。如果线程需要等待某些锁那么调用对象中的wait()方法就有意义了。如果wait()方法定义在Thread类中，线程正在等待的是哪个锁就不明显了。
	简单的说，由于wait，notify和notifyAll都是锁级别的操作，所以把他们定义在Object类中是因为锁属于对象。